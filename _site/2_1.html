几个重要问题	验证
	无论数组的初始状态是什么，排序算法都能成功吗？
	尽管一般都会测试代码并从数学上证明算法的正确性，但在实现每个排序算法时加上isSorted(arr)语句仍然是必要的。
	需要注意的是，如果我们只使用exch() 来交换数组的元素，这个测试就足够了。当我们直接将值存入数组中时，这条语句无法提供足够的保证（例如，把初始输入数组的元素全部置为相同的值也能通过这个测试）。
	运行时间
	首先，计算各个排序算法在不同的随机输入下的基本操作的次数（包括比较和交换，或是读写数组的次数）。
	然后，我们根据这些数据来估计算法的相对性能，并介绍在实验中验证这些猜想所用到的工具。

	额外的内存使用
	将排序算法分为两类，原地排序算法，以及需要额外空间存储另一份数组副本的其他排序算法。
	数据类型
	适用于任何可比较的数据类型。
选择排序	算法
	首先，找到数组中最小的元素；
	其次，将它和数组的第一个元素交换位置；
	循环至整个数组排序。
	时间效率
	交换的总次数是N；
	算法的时间效率取决于比较的次数。
	第i个元素要经过N-i-1次比较和1次交换。
	比较总次数为N2/2。
	特点
	运行时间和输入无关。（某些情况下是缺点）
	数据移动是最少的。
插入排序	算法
	将一个元素插入到已排序序列的适当位置。
	时间效率
	平均
	N2/4次比较以及N2/4次交换。
	最差
	N2/2次比较以及N2/2次交换。（倒序）
	最好
	N-1次比较以及0次交换。（已排序）
	特点
	运行时间与输入有关。
	插入排序对部分有序的数组十分高效，也很适合小规模数组。

	部分有序数组
	如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。
	*倒置指的是数组中的两个顺序颠倒的元素。
	典型的部分有序的数组
	• 数组中每个元素距离它的最终位置都不远；
	• 一个有序的大数组接一个小数组；
	• 数组中只有几个元素的位置不正确。
比较两种排序算法	步骤
	• 实现并调试它们；
	• 分析它们的基本性质；
	• 对它们的相对性能作出猜想；
	• 用实验验证我们的猜想。
	猜想
	对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间都是平方级别的，两者之比应该是一个较小的常数。
希尔排序	算法
	使数组中任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。
	对于每个h，用插入排序将h个子数组独立地排序，直到h为1时，将数组完全排序。
	把用到的h组成的序列称为增量序列。
	时间效率
	希尔排序高效的原因是权衡了字数组的规模和有序性。排序之初各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。
	子数组部分有序的程度取决于增量序列的选择。
	无法准确描述其性能。
	特点
	• 可以用于大型数组。
	• 对任意排序的数组表现也很好。
	性质
	使用增量序列1，4，13，40，121，364…的希尔排序所需的比较次数不会超出N的若干倍乘以增量序列的长度。
